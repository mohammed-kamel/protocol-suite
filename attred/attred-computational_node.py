'''
| Attred for Resource Discovery 
| Notes:          computational node 
| type:           decentralized CP-ABE
| setting:        Pairing
| modified by:    Mohammed
| on:             08/05/2021 (not yet a final source code)
'''
from charm.toolbox.pairinggroup import PairingGroup,ZR,G1,G2,GT,pair
from charm.toolbox.secretutil import SecretUtil
from charm.toolbox.ABEnc import ABEnc, Input, Output
from charm.toolbox.ABEncMultiAuth import ABEncMultiAuth
from charm.toolbox.symcrypto import AuthenticatedCryptoAbstraction, SymmetricCryptoAbstraction
from charm.core.math.pairing import hashPair as extractor
import time
from datetime import timedelta


# type annotations
pk_t = { 'g':G1, 'g2':G2, 'h':G1, 'f':G1, 'e_gg_alpha':GT }
mk_t = {'beta':ZR, 'g2_alpha':G2 }
sk_t = { 'D':G2, 'Dj':G2, 'Djp':G1, 'S':str }
ct_t = { 'C_tilde':GT, 'C':G1, 'Cy':G1, 'Cyp':G2 }

debug = False
class attredv1(ABEncMultiAuth):
         
    def __init__(self, groupObj):
        ABEnc.__init__(self)
        global util, group
        util = SecretUtil(groupObj, verbose=False)	#Create Secret Sharing Scheme
        group = groupObj				#:Prime order group

    def setup(self):
        g = group.random(G1)
        H = lambda x: group.hash(x, G1)
        GP = {'g':g, 'H': H}
        return GP

    def authsetup(self, GP, attributes):
        SK = {} #dictionary of {s: {alpha_i, beta_i}} 
        PK = {} #dictionary of {s: {e(g,g)^alpha_i, g^y}}
        for i in attributes: # This is done for each attribue that this AA handles
            alpha_i, beta_i = group.random(), group.random()   	# two random group elements
            e_gg_alpha_i = pair(GP['g'],GP['g']) ** alpha_i 	# first part of the PK
            g_beta_i = GP['g'] ** beta_i                          	# second part of the PK
            SK[i.upper()] = {'alpha_i': alpha_i, 'beta_i': beta_i} 	# The random group elements are the SK
            PK[i.upper()] = {'e(gg)^alpha_i': e_gg_alpha_i, 'g^beta_i': g_beta_i}

        if(debug):
            print("Authority Setup for %s" % attributes)
            print("SK = {alpha_i, beta_i}")
            print(SK)
            print("PK = {e(g,g) ^ alpha_i, g ^ beta_i}")
            print(PK)

        return (SK, PK)
    


    
    
    def encrypt(self, GP, pk, M, policy_str):
        '''Encrypt'''
        # M is a group element (will be used later as the key for symmetric encryption)
        # pk is a dictionary with all the attributes of all authorities put together.
        
        sj = group.random() # Assume it has been received from an IoT gateway
        wj = group.init(ZR, 0) # Assume it has been received from an IoT gateway
        C1, C2, C3 = {}, {}, {}

        # This part is generated by the gateway and sent to the computational node 
        policy = util.createPolicy(policy_str)
        sj_shares = util.calculateSharesList(sj, policy) # create the shares of the secret s (note that s_0 = s)
        wj_shares = util.calculateSharesList(wj, policy) # w_x = A_x . w (note that w_0 = 0)
        sj_shares = dict([(x[0].getAttributeAndIndex(), x[1]) for x in sj_shares])
        wj_shares = dict([(x[0].getAttributeAndIndex(), x[1]) for x in wj_shares])
        rx = [] # This should be received in an array, r_i for each attribute i. For sake of simplicity we keep using the same value. 
        for attr,s_share in sj_shares.items():
            rx.append(group.random()) 
        # ------------------------------------------------------------------------


        # Here are the computations done by a computational node
        start_time = time.monotonic()
        egg_sj = pair(GP['g'], GP['g']) ** sj
        e = 0
        for attr, sj_share in sj_shares.items():
            k_attr = util.strip_index(attr)	
            wj_share = wj_shares[attr]
            C1[attr] = (pair(GP['g'],GP['g']) ** sj_share) * (pk[k_attr]['e(gg)^alpha_i'] ** rx[e])
            C2[attr] = GP['g'] ** rx[e]
            C3[attr] = (pk[k_attr]['g^beta_i'] ** rx[e]) * (GP['g'] ** wj_share) 
            e = e + 1
        end_time = time.monotonic()
        print("Execution Time (Only for computational nodes) : ", timedelta(seconds=end_time - start_time))
        return {'egg_sj':egg_sj, 'C1':C1, 'C2':C2, 'C3':C3, 'policy':policy_str} 

    

def main():   
    groupObj = PairingGroup('SS512')

    attred = attredv1(groupObj)
    GP = attred.setup()
    
    auth1_attrs = ['ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT', 'NINE', 'TEN']
    (SK_auth1, PK_auth1) = attred.authsetup(GP, auth1_attrs)
    if debug: print("Authority 1 SK")
    if debug: print(SK_auth1)
    
    discovery_policy = '((four or three) and (one))' # access policy to IoT resource

    if debug:
        print("Resource Access Policy =>", discovery_policy)

    
    # This section is done by resource registration entity
    rand_key = groupObj.random(GT)
    CT = attred.encrypt(GP, PK_auth1, rand_key, discovery_policy) # Main ABE encryption (of the random key)
    
if __name__ == "__main__":
    debug = True
    main()
   

